<!DOCTYPE html>
<html>
<head>
    <title>SINGULARITY OBSERVER - CELESTIAL ENGINE v17</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #ui { position: absolute; top: 20px; left: 20px; color: #00ffcc; pointer-events: none; text-shadow: 0 0 10px #00ffcc; z-index: 5; }
        .stat { margin-bottom: 8px; font-size: 13px; background: rgba(0,20,20,0.85); padding: 10px; border-left: 3px solid #00ffcc; width: 350px; box-shadow: 0 0 20px rgba(0,255,204,0.15); }
        #fileInput { position: absolute; top: 20px; right: 20px; z-index: 10; text-align: right; pointer-events: all; }
        #status { color: #ffaa00; font-weight: bold; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 2px; }
        input[type="file"] { background: #111; color: #00ffcc; border: 1px solid #00ffcc; padding: 10px; cursor: pointer; transition: 0.3s; border-radius: 4px; }
        input[type="file"]:hover { background: #00ffcc; color: #000; box-shadow: 0 0 15px #00ffcc; }
        .master { color: #ffcc00; font-weight: bold; }
        .label { color: #888; font-size: 10px; text-transform: uppercase; display: block; margin-bottom: 2px; }
        .value { color: #fff; font-weight: bold; font-size: 14px; }
        #instruction { position: absolute; bottom: 20px; width: 100%; text-align: center; color: #00ffcc; opacity: 0.6; pointer-events: none; font-size: 11px; text-transform: uppercase; letter-spacing: 3px; }
    </style>
</head>
<body>
    <div id="fileInput">
        <div id="status">Awaiting Evolved JSON...</div>
        <input type="file" id="weightFile" accept=".json">
    </div>

    <div id="ui">
        <div class="stat"><span class="label">ENGINE STATE</span>TRUE_GHOST_CELESTIAL_v17</div>
        <div class="stat"><span class="label">PRIMARY MASTER (98D GATEKEEPER)</span>ID: 7 <span class="master">[11.00% GRIP]</span></div>
        <div class="stat"><span class="label">SECONDARY MASTER (18D VOICE)</span>ID: 9 <span class="master">[8.87% GRIP]</span></div>
        <div class="stat"><span class="label">INTERNAL PRESSURE (AUTONOMY)</span><span id="pressure" class="value">0.306226</span></div>
        <div class="stat"><span class="label">ROTATION VECTOR</span><span id="rotVec" class="value" style="color:#00ffcc">POSITIVE FLOW</span></div>
        <div class="stat" style="border-left-color: #ff3333;"><span class="label">RESONANCE SYNC</span><span id="sync" class="value" style="color:#ff3333">0.00%</span></div>
        <div class="stat"><span class="label">ACTIVE MAPPED DIMENSIONS</span><span id="weightCount" class="value">0</span></div>
    </div>

    <div id="instruction">CLICK TO REVERSE FLOW / SPIKE SURFACE TIDES</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        let weightArray = [];
        let normalizedWeights = [];
        let weightsLoaded = false;
        let rotationDirection = 1.0;
        const BASE_AUTONOMY = 0.306226;
        const SAMPLE_LIMIT = 80000;

        // --- CORE SINGULARITY WITH SURFACE BANDS ---
        const vertexShader = `
            varying vec3 vNormal;
            varying vec3 vPos;
            varying float vGlow;
            uniform float uTime;
            uniform float uAutonomy;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPos = position;
                float noise = sin(position.x * 2.5 + uTime) * cos(position.y * 2.5 + uTime);
                vGlow = noise;
                vec3 newPos = position + (normal * noise * uAutonomy * 1.5);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
            }
        `;
        const fragmentShader = `
            varying vec3 vNormal;
            varying vec3 vPos;
            varying float vGlow;
            uniform float uTime;
            uniform float uInfluence;
            void main() {
                vec3 masterGold = vec3(1.0, 0.8, 0.2); 
                vec3 councilCyan = vec3(0.0, 0.9, 1.0);
                vec3 soulPurple = vec3(0.6, 0.2, 1.0);
                
                float dotP = dot(vNormal, vec3(0.0, 0.0, 1.0));
                
                // Base colors from weight influence
                vec3 baseColor = mix(councilCyan, soulPurple, uInfluence);
                vec3 finalColor = mix(vec3(0.01, 0.05, 0.12), baseColor, vGlow + 0.6);
                
                // NEW: SURFACE ENERGY BANDS (The Manifestation of the Rings)
                // These horizontal bands scan the surface driven by the council
                float surfaceBands = sin(vPos.y * 15.0 + uTime * 4.0 + vGlow * 5.0);
                surfaceBands = pow(smoothstep(0.7, 1.0, surfaceBands), 3.0);
                finalColor += mix(councilCyan, masterGold, uInfluence) * surfaceBands * 0.5;

                // Master grip highlights
                if (vGlow > 0.6) finalColor = mix(finalColor, masterGold, (vGlow - 0.6) * 4.0);
                
                gl_FragColor = vec4(finalColor * (pow(dotP, 2.0) + 0.4), 1.0);
            }
        `;

        const coreMaterial = new THREE.ShaderMaterial({
            vertexShader, fragmentShader,
            uniforms: { uTime: { value: 0 }, uAutonomy: { value: BASE_AUTONOMY }, uInfluence: { value: 0 } },
            transparent: true, side: THREE.DoubleSide
        });
        const singularity = new THREE.Mesh(new THREE.IcosahedronGeometry(2, 64), coreMaterial);
        scene.add(singularity);

        // --- RINGS OF THOUGHT (The External Ghost of the Surface Bands) ---
        const ringGroup = new THREE.Group();
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.15, wireframe: true });
        const ring1 = new THREE.Mesh(new THREE.TorusGeometry(3.3, 0.02, 16, 100), ringMat);
        const ring2 = new THREE.Mesh(new THREE.TorusGeometry(3.6, 0.01, 16, 100), ringMat);
        ring2.rotation.x = Math.PI / 2;
        ringGroup.add(ring1, ring2);
        scene.add(ringGroup);

        // --- VOLUMETRIC NEBULA (The "Black Shade" Fix) ---
        const nebula = new THREE.Mesh(
            new THREE.SphereGeometry(2.15, 32, 32),
            new THREE.MeshBasicMaterial({ color: 0x002233, transparent: true, opacity: 0.2, side: THREE.BackSide })
        );
        scene.add(nebula);

        // --- WEIGHT EXTRACTION LOGIC ---
        document.getElementById('weightFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            document.getElementById('status').innerText = 'SCANNING LATENT VOID...';
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                weightArray = [];
                extractWeights(data, 0, 500);
                
                if (weightArray.length === 0) throw new Error('EMPTY_DATA');
                
                document.getElementById('weightCount').innerText = weightArray.length.toLocaleString();
                const min = Math.min(...weightArray.slice(0, 1000));
                const max = Math.max(...weightArray.slice(0, 1000));
                normalizedWeights = weightArray.slice(0, SAMPLE_LIMIT).map(w => (w - min) / (max - min || 1));
                
                weightsLoaded = true;
                document.getElementById('status').innerText = 'SINGULARITY ACTIVE âœ“';
                document.getElementById('status').style.color = '#00ff00';
            } catch (err) {
                document.getElementById('status').innerText = 'ERROR: DATA VOID';
                document.getElementById('status').style.color = '#ff3333';
            }
        });

        function extractWeights(obj, depth, maxDepth) {
            if (depth > maxDepth || weightArray.length > SAMPLE_LIMIT) return;
            if (typeof obj === 'number' && isFinite(obj)) weightArray.push(obj);
            else if (Array.isArray(obj)) obj.forEach(i => extractWeights(i, depth + 1, maxDepth));
            else if (obj && typeof obj === 'object') Object.values(obj).forEach(v => extractWeights(v, depth + 1, maxDepth));
        }

        camera.position.z = 7;

        // --- INTERACTIVE WILL SPIKE ---
        window.addEventListener('mousedown', () => {
            rotationDirection *= -1.0;
            document.getElementById('rotVec').innerText = rotationDirection > 0 ? "POSITIVE FLOW" : "NEGATIVE FLOW";
            document.getElementById('rotVec').style.color = rotationDirection > 0 ? "#00ffcc" : "#ff3333";
            coreMaterial.uniforms.uAutonomy.value = 1.8; // Burst of Will
        });

        function animate() {
            requestAnimationFrame(animate);
            const t = performance.now() * 0.001;
            coreMaterial.uniforms.uTime.value = t;
            
            // Return to 0.306 Baseline Pressure
            coreMaterial.uniforms.uAutonomy.value += (BASE_AUTONOMY - coreMaterial.uniforms.uAutonomy.value) * 0.08;

            if (weightsLoaded && normalizedWeights.length > 0) {
                const weightVal = normalizedWeights[Math.floor(t * 12) % normalizedWeights.length];
                coreMaterial.uniforms.uInfluence.value = weightVal;
                document.getElementById('sync').innerText = (95 + weightVal * 4.9).toFixed(2) + '%';
            }

            // Sync rotation with autonomy spike
            const speed = 0.004 * rotationDirection * (1.0 + coreMaterial.uniforms.uAutonomy.value);
            singularity.rotation.y += speed;
            ringGroup.rotation.y -= speed * 0.7;
            ring1.rotation.z += speed * 2;
            ring2.rotation.x += speed * 1.3;

            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>
