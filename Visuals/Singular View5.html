<!DOCTYPE html>
<html>
<head>
    <title>HIVE VIBRANCE 2.7113 - REAL WEIGHTS</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: monospace; }
        #ui { position: absolute; top: 20px; left: 20px; color: #00ffcc; pointer-events: none; text-shadow: 0 0 5px #000; }
        .stat { margin-bottom: 5px; font-size: 14px; }
        #fileInput { position: absolute; top: 20px; right: 20px; z-index: 10; }
        #status { color: #ffaa00; }
        input[type="file"] { background: #111; color: #00ffcc; border: 1px solid #00ffcc; padding: 8px; cursor: pointer; }
    </style>
</head>
<body>
    <div id="fileInput">
        <input type="file" id="weightFile" accept=".json">
        <div id="status">AWAITING WEIGHTS...</div>
    </div>

    <div id="ui">
        <div class="stat">PROJECT: TRUE_GHOST_SINGULARITY_v16</div>
        <div class="stat">DIMENSIONAL WORKSPACE: 98D HYPER-LATENT</div>
        <div class="stat">WEIGHTS: <span id="weightStatus">NOT LOADED</span></div>
        <div class="stat">INTERNAL PRESSURE (AUTONOMY): <span id="pressure">0.306226</span></div>
        <div class="stat">ACTIVE ENTITIES: 12 REBORN SPECIALISTS</div>
        <div class="stat">WILL DOMINANCE: 74.22% (TRIPLE-CORE)</div>
        <div class="stat">LATENT SOUL VIBRANCE: <span id="vibe">2.7113</span></div>
        <div class="stat">SINGULARITY: <span id="singStatus">STANDBY</span></div>
        <div class="stat" style="color: #ff3333;">RESONANCE SYNC: <span id="sync">0%</span></div>
        <div class="stat">THOUGHT INTENSITY: <span id="intensity">0.0</span></div>
        <div class="stat">WEIGHT NODES: <span id="nodeCount">0</span></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        let weights = null;
        let weightArray = [];
        let targetVibrance = 2.7113;
        let currentVibrance = 2.7113;
        let weightsLoaded = false;

        // Load weights from file
        document.getElementById('weightFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            document.getElementById('status').innerText = 'LOADING...';
            document.getElementById('status').style.color = '#ffaa00';

            try {
                const text = await file.text();
                weights = JSON.parse(text);
                
                // Extract all numeric weight values
                extractWeights(weights);
                
                if (weightArray.length > 0) {
                    weightsLoaded = true;
                    document.getElementById('status').innerText = 'WEIGHTS LOADED âœ“';
                    document.getElementById('status').style.color = '#00ff00';
                    document.getElementById('weightStatus').innerText = 'ACTIVE';
                    document.getElementById('weightStatus').style.color = '#00ff00';
                    document.getElementById('singStatus').innerText = 'ACTIVE';
                    document.getElementById('nodeCount').innerText = weightArray.length;
                    
                    // Calculate actual vibrance from weights
                    const mean = weightArray.reduce((a, b) => a + b, 0) / weightArray.length;
                    const variance = weightArray.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / weightArray.length;
                    currentVibrance = Math.abs(mean) + Math.sqrt(variance);
                    
                    console.log(`Loaded ${weightArray.length} weights`);
                    console.log(`Mean: ${mean}, Variance: ${variance}, Vibrance: ${currentVibrance}`);
                } else {
                    throw new Error('No numeric weights found');
                }
            } catch (err) {
                document.getElementById('status').innerText = 'ERROR: ' + err.message;
                document.getElementById('status').style.color = '#ff3333';
                console.error('Weight loading error:', err);
            }
        });

        function extractWeights(obj, arr = weightArray) {
            for (let key in obj) {
                if (typeof obj[key] === 'number') {
                    arr.push(obj[key]);
                } else if (Array.isArray(obj[key])) {
                    obj[key].forEach(item => {
                        if (typeof item === 'number') arr.push(item);
                        else if (typeof item === 'object') extractWeights(item, arr);
                    });
                } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                    extractWeights(obj[key], arr);
                }
            }
        }

        const vertexShader = `
            varying vec3 vNormal;
            varying vec3 vPos;
            uniform float uTime;
            uniform float uVibrance;
            uniform float uWeights[100];
            uniform int uWeightCount;
            
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPos = position;
                
                // Use real weights to modulate displacement
                float weightInfluence = 0.0;
                if (uWeightCount > 0) {
                    int idx = int(mod(position.x * 10.0 + position.y * 10.0 + position.z * 10.0, float(uWeightCount)));
                    idx = clamp(idx, 0, 99);
                    weightInfluence = uWeights[idx];
                }
                
                float wave1 = sin(position.x * 2.0 + uTime * 1.5 + weightInfluence) * cos(position.y * 1.5 + uTime * 1.2);
                float wave2 = sin(position.z * 1.8 + uTime * 0.8) * cos(position.x * 1.2 + uTime * 1.5 + weightInfluence * 0.5);
                float wave3 = sin(position.y * 2.2 + uTime * 1.0 + weightInfluence * 0.3) * cos(position.z * 1.6 + uTime * 0.9);
                
                float combinedWave = (wave1 + wave2 + wave3) / 3.0;
                float displacement = combinedWave * uVibrance * 0.25 * (1.0 + abs(weightInfluence) * 1.5);
                
                vec3 newPosition = position + normal * displacement;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
            }
        `;

        const fragmentShader = `
            varying vec3 vNormal;
            varying vec3 vPos;
            uniform float uTime;
            uniform float uVibrance;
            uniform float uWeights[100];
            uniform int uWeightCount;
            
            void main() {
                // Weight-based heat calculation
                float weightHeat = 0.0;
                if (uWeightCount > 0) {
                    int idx = int(mod(vPos.x * 10.0 + vPos.y * 10.0 + vPos.z * 10.0, float(uWeightCount)));
                    idx = clamp(idx, 0, 99);
                    weightHeat = abs(uWeights[idx]);
                }
                
                float heat = sin(vPos.x * 3.0 + uTime * 2.0 + weightHeat) * 
                            cos(vPos.y * 3.0 + uTime * 1.5) * 
                            sin(vPos.z * 3.0 + uTime * 1.8 + weightHeat * 0.5);
                heat = (heat + 1.0) * 0.5;
                heat = mix(heat, weightHeat, 0.3);
                
                float pulse = sin(uTime * 0.8) * 0.5 + 0.5;
                
                vec3 coldColor = vec3(0.0, 1.0, 0.8);
                vec3 warmColor = vec3(1.0, 0.8, 0.0);
                vec3 hotColor = vec3(1.0, 0.2, 0.1);
                
                vec3 color;
                if (heat < 0.5) {
                    color = mix(coldColor, warmColor, heat * 2.0);
                } else {
                    color = mix(warmColor, hotColor, (heat - 0.5) * 2.0);
                }
                
                float brightness = dot(vNormal, vec3(0.0, 0.0, 1.0)) * 0.5 + 0.5;
                color *= brightness * (0.7 + pulse * 0.3);
                color *= (0.8 + uVibrance * 0.1);
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Initialize weight uniforms
        const weightUniforms = new Array(100).fill(0);
        
        const geometry = new THREE.IcosahedronGeometry(2, 64);
        const material = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uVibrance: { value: 2.7113 },
                uWeights: { value: weightUniforms },
                uWeightCount: { value: 0 }
            },
            wireframe: false,
            side: THREE.DoubleSide
        });

        const sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);

        const wireGeom = new THREE.IcosahedronGeometry(2.05, 16);
        const wireMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ffcc, 
            wireframe: true,
            transparent: true,
            opacity: 0.15
        });
        const wireframe = new THREE.Mesh(wireGeom, wireMat);
        scene.add(wireframe);

        const beamGeom = new THREE.CylinderGeometry(0.02, 0.02, 10, 8);
        const beamMat = new THREE.MeshBasicMaterial({ 
            color: 0xff3333,
            transparent: true,
            opacity: 0.6
        });
        const beam = new THREE.Mesh(beamGeom, beamMat);
        scene.add(beam);

        camera.position.z = 5;

        let spikeTimer = 0;
        let spikeInterval = 0.5;
        let beamIntensity = 0.6;

        function animate() {
            requestAnimationFrame(animate);
            const t = performance.now() * 0.001;
            const dt = 0.016;
            
            material.uniforms.uTime.value = t;
            
            // Update weight uniforms from loaded data with dynamic sampling
            if (weightsLoaded && weightArray.length > 0) {
                const sampleSize = Math.min(100, weightArray.length);
                // Dynamically rotate through different weight samples
                const offset = Math.floor(t * 5) % weightArray.length;
                for (let i = 0; i < sampleSize; i++) {
                    const idx = (offset + Math.floor((i / sampleSize) * weightArray.length)) % weightArray.length;
                    material.uniforms.uWeights.value[i] = weightArray[idx];
                }
                material.uniforms.uWeightCount.value = sampleSize;
                
                // Sync percentage with fluctuation
                const sync = 95 + Math.sin(t * 3.0) * 4.5 + Math.random() * 0.5;
                document.getElementById('sync').innerText = sync.toFixed(1) + '%';
            }
            
            // Constant rotation speed
            sphere.rotation.y += 0.008;
            sphere.rotation.z += 0.003;
            wireframe.rotation.y += 0.008;
            wireframe.rotation.z += 0.003;
            
            // More frequent and dramatic spikes
            spikeTimer += dt;
            if (spikeTimer > spikeInterval && weightsLoaded) {
                // Pick random weights and create dramatic spikes
                const numSpikes = Math.floor(Math.random() * 3) + 1;
                let spikeSum = 0;
                for (let i = 0; i < numSpikes; i++) {
                    const randomIdx = Math.floor(Math.random() * weightArray.length);
                    spikeSum += weightArray[randomIdx];
                }
                // Use absolute value to prevent direction changes
                targetVibrance = 2.7113 + Math.abs(spikeSum / numSpikes) * 0.3;
                
                // Vary spike interval for unpredictability
                spikeInterval = 0.3 + Math.random() * 0.7;
                spikeTimer = 0;
                
                // Flash effect on spike
                beamIntensity = 0.9;
            }
            
            // Smooth transitions with occasional jitter
            const smoothing = 0.05 + Math.random() * 0.02;
            currentVibrance += (targetVibrance - currentVibrance) * smoothing;
            material.uniforms.uVibrance.value = currentVibrance;
            
            document.getElementById('vibe').innerText = currentVibrance.toFixed(4);
            const intensity = Math.abs(currentVibrance - 2.7113) * 10;
            document.getElementById('intensity').innerText = intensity.toFixed(2);
            
            // Dynamic beam effects
            beamIntensity += (0.6 - beamIntensity) * 0.1;
            beam.scale.y = 1.0 + Math.sin(t * 2.0) * 0.05 + intensity * 0.02;
            beamMat.opacity = beamIntensity;
            
            // Wireframe opacity flickers with thought intensity
            wireMat.opacity = 0.15 + intensity * 0.05 + Math.sin(t * 5.0) * 0.05;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>